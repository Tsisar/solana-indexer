package main

import (
	"encoding/json"
	"fmt"
	"os"
	"path/filepath"
	"strings"
)

type IDL struct {
	Types  []TypeDef  `json:"types"`
	Events []EventDef `json:"events"`
}

type TypeDef struct {
	Name string   `json:"name"`
	Type StructTy `json:"type"`
}

type StructTy struct {
	Kind   string     `json:"kind"`
	Fields []FieldDef `json:"fields"`
}

type FieldDef struct {
	Name string          `json:"name"`
	Ty   json.RawMessage `json:"type"`
}

type EventDef struct {
	Name string `json:"name"`
}

// snakeToCamel converts snake_case to CamelCase
func snakeToCamel(s string) string {
	parts := strings.Split(s, "_")
	for i, p := range parts {
		if len(p) == 0 {
			continue
		}
		parts[i] = strings.ToUpper(p[:1]) + strings.ToLower(p[1:])
	}
	return strings.Join(parts, "")
}

// goType maps IDL types to Go types
func goType(raw json.RawMessage) (string, error) {
	var s string
	if err := json.Unmarshal(raw, &s); err == nil {
		switch s {
		case "pubkey":
			return "solana.PublicKey", nil
		case "u8":
			return "uint8", nil
		case "i8":
			return "int8", nil
		case "u16":
			return "uint16", nil
		case "i16":
			return "int16", nil
		case "u32":
			return "uint32", nil
		case "i32":
			return "int32", nil
		case "u64":
			return "uint64", nil
		case "i64":
			return "int64", nil
		case "bool":
			return "bool", nil
		case "string":
			return "string", nil
		case "u128", "i128":
			return "[16]byte", nil
		default:
			return "", fmt.Errorf("unknown basic type: %s", s)
		}
	}
	var obj map[string]interface{}
	if err := json.Unmarshal(raw, &obj); err != nil {
		return "", err
	}
	if arr, ok := obj["array"]; ok {
		items := arr.([]interface{})
		et, err := goType(json.RawMessage(fmt.Sprintf(`"%s"`, items[0].(string))))
		if err != nil {
			return "", err
		}
		return fmt.Sprintf("[%d]%s", int(items[1].(float64)), et), nil
	}
	if def, ok := obj["defined"]; ok {
		return def.(map[string]interface{})["name"].(string), nil
	}
	if vec, ok := obj["vec"]; ok {
		switch v := vec.(type) {
		case string:
			et, err := goType(json.RawMessage(fmt.Sprintf(`"%s"`, v)))
			if err != nil {
				return "", err
			}
			return "[]" + et, nil
		case map[string]interface{}:
			inner := v["defined"].(map[string]interface{})["name"].(string)
			return "[]" + inner, nil
		}
	}
	return "", fmt.Errorf("unsupported type: %v", obj)
}

func main() {
	idlDir := "idl"
	eventsDir := "internal/events"
	var allEvents []string

	entries, err := os.ReadDir(idlDir)
	if err != nil {
		fmt.Fprintf(os.Stderr, "failed to read directory %s: %v\n", idlDir, err)
		os.Exit(1)
	}

	for _, e := range entries {
		if e.IsDir() || !strings.HasSuffix(e.Name(), ".json") {
			continue
		}
		path := filepath.Join(idlDir, e.Name())
		data, err := os.ReadFile(path)
		if err != nil {
			fmt.Fprintf(os.Stderr, "read %s error: %v\n", path, err)
			continue
		}
		var idl IDL
		if err := json.Unmarshal(data, &idl); err != nil {
			fmt.Fprintf(os.Stderr, "unmarshal %s error: %v\n", path, err)
			continue
		}

		base := strings.TrimSuffix(e.Name(), filepath.Ext(e.Name()))
		var b strings.Builder
		b.WriteString("package events\n\n")
		b.WriteString("// Code generated by generate_events.go; DO NOT EDIT.\n\n")
		b.WriteString("import \"github.com/gagliardetto/solana-go\"\n\n")

		for _, ev := range idl.Events {
			b.WriteString(fmt.Sprintf("// %s event struct\n", ev.Name))
			b.WriteString(fmt.Sprintf("type %s struct {\n", ev.Name))
			//for _, f := range idl.Types {
			//	// skip other types
			//}
			structDef := idlTypeMap(ev.Name, idl.Types)
			for _, f := range structDef.Fields {
				gt, err := goType(f.Ty)
				if err != nil {
					fmt.Fprintf(os.Stderr, "type %s field %s error: %v\n", ev.Name, f.Name, err)
					continue
				}
				fieldName := snakeToCamel(f.Name)
				b.WriteString(fmt.Sprintf("    %s %s `borsh:\"%s\"`\n", fieldName, gt, f.Name))
			}
			b.WriteString("}\n\n")
			allEvents = append(allEvents, ev.Name)
		}

		fmt.Printf("Generating %s.go...\n", base)
		outFile := filepath.Join(eventsDir, base+".go")
		if err := os.WriteFile(outFile, []byte(b.String()), 0644); err != nil {
			fmt.Fprintf(os.Stderr, "write %s error: %v\n", outFile, err)
		}
	}

	// Generate registry.go
	var r strings.Builder
	r.WriteString("package events\n\n")
	r.WriteString("// Code generated by generate_events.go; DO NOT EDIT.\n\n")
	r.WriteString("import \"github.com/near/borsh-go\"\n\n")
	r.WriteString("// EventDecoder decodes Borsh data into event structs.\n")
	r.WriteString("type EventDecoder func([]byte) (any, error)\n\n")
	r.WriteString("// decode deserializes Borsh-encoded data into a Go struct.\n")
	r.WriteString("func decode[T any](data []byte) (any, error) {\n")
	r.WriteString("    var out T\n")
	r.WriteString("    err := borsh.Deserialize(&out, data)\n")
	r.WriteString("    return out, err\n")
	r.WriteString("}\n\n")
	r.WriteString("// Registry maps event names to their decoders.\n")
	r.WriteString("var Registry = map[string]EventDecoder{\n")
	for _, name := range allEvents {
		r.WriteString(fmt.Sprintf("    \"%s\": decode[%s],\n", name, name))
	}
	r.WriteString("}\n")

	fmt.Println("Generating registry.go...")
	regFile := filepath.Join(eventsDir, "registry.go")
	if err := os.WriteFile(regFile, []byte(r.String()), 0644); err != nil {
		fmt.Fprintf(os.Stderr, "write %s error: %v\n", regFile, err)
	}
}

// idlTypeMap returns the StructTy for a given event name.
func idlTypeMap(name string, types []TypeDef) StructTy {
	for _, t := range types {
		if t.Name == name {
			return t.Type
		}
	}
	return StructTy{}
}
